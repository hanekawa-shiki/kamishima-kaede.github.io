"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[9447],{4344:(s,a,e)=>{e.r(a),e.d(a,{comp:()=>p,data:()=>r});var n=e(9034);const l=(0,n.Lk)("p",null,"平时看到的变成思想记录",-1),o=(0,n.Fv)('<h2 id="哨兵变量" tabindex="-1"><a class="header-anchor" href="#哨兵变量"><span>哨兵变量</span></a></h2><blockquote><p>由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量。--《深入浅出Node.js》﹒朴灵</p></blockquote><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">var</span><span style="color:#88C0D0;"> after</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> function</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">times</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> callback</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  var</span><span style="color:#D8DEE9;"> count</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 0</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> results</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#81A1C1;"> function</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">key</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> value</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    results</span><span style="color:#D8DEE9FF;">[</span><span style="color:#D8DEE9;">key</span><span style="color:#D8DEE9FF;">] </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9;"> value</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    count</span><span style="color:#81A1C1;">++;</span></span>\n<span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">count</span><span style="color:#81A1C1;"> ===</span><span style="color:#D8DEE9;"> times</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#88C0D0;">      callback</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">results</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">var</span><span style="color:#D8DEE9;"> done</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> after</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">times</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> render</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Node基于事件驱动和非阻塞设计，在分布式环境中尤其能发挥出它的特长，基于事件驱动可以实现与大量的客户端进行连接，非阻塞设计则让它可以更好地提升网络的响应吞吐。Node提供了相对底层的网络调用，以及基于事件的编程接口，使得开发者在这些模块上十分轻松地构建网络应用。</p></blockquote>',4),t={},p=(0,e(8538).A)(t,[["render",function(s,a){return(0,n.uX)(),(0,n.CE)("div",null,[l,(0,n.Q3)(" more "),o])}]]),r=JSON.parse('{"path":"/programming_ideas/","title":"编程思维积累","lang":"zh-CN","frontmatter":{"title":"编程思维积累","icon":"list","category":"编程","tag":["ideas"],"isOriginal":true,"date":"2022-08-09T00:00:00.000Z","description":"平时看到的变成思想记录","head":[["meta",{"property":"og:url","content":"https://hanekawa.top/programming_ideas/"}],["meta",{"property":"og:site_name","content":"hanekawa-shiki"}],["meta",{"property":"og:title","content":"编程思维积累"}],["meta",{"property":"og:description","content":"平时看到的变成思想记录"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-16T03:42:08.000Z"}],["meta",{"property":"article:author","content":"hanekawa-shiki"}],["meta",{"property":"article:tag","content":"ideas"}],["meta",{"property":"article:published_time","content":"2022-08-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-16T03:42:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程思维积累\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-08-09T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-16T03:42:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hanekawa-shiki\\",\\"url\\":\\"https://hanekawa.top\\"}]}"]]},"headers":[{"level":2,"title":"哨兵变量","slug":"哨兵变量","link":"#哨兵变量","children":[]}],"git":{"createdTime":1660039367000,"updatedTime":1676518928000,"contributors":[{"name":"shiki","email":"kamiacgxu@gmail.com","commits":2},{"name":"shiki ryougi","email":"shikiryougi@shikideMacBook.local","commits":1}]},"readingTime":{"minutes":0.93,"words":279},"filePathRelative":"programming_ideas/README.md","localizedDate":"2022年8月9日","excerpt":"<p>平时看到的变成思想记录</p>\\n","autoDesc":true}')},8538:(s,a)=>{a.A=(s,a)=>{const e=s.__vccOpts||s;for(const[s,n]of a)e[s]=n;return e}}}]);