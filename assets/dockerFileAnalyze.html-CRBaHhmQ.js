import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,b as r}from"./app-DzQ4eOgD.js";const i="/assets/003-D0PIagLO.png",l="/assets/004-C44Ia1yv.png",d="/assets/005-Dua-ISps.png",p={},t=r('<h2 id="dockerfile解析" tabindex="-1"><a class="header-anchor" href="#dockerfile解析"><span><code>dockerFile</code>解析</span></a></h2><h3 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h3><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener noreferrer">Dockerfile</a>是用来构建<code>Docker</code>镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><figure><img src="'+i+'" alt="概述" tabindex="0" loading="lazy"><figcaption>概述</figcaption></figure><p>构建三步骤：</p><ul><li>1.编写<code>Dockerfile</code>文件</li><li>2.<code>docker build</code>命令构建镜像</li><li>3.<code>docker run</code>依镜像运行容器实例</li></ul><h2 id="dockerfile内容基础知识" tabindex="-1"><a class="header-anchor" href="#dockerfile内容基础知识"><span><code>Dockerfile</code>内容基础知识</span></a></h2><p>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p><p>2：指令按照从上到下，顺序执行</p><p>3：<code>#</code>表示注释</p><p>4：每条指令都会创建一个新的镜像层并对镜像进行提交</p><p><code>Docker</code>执行<code>Dockerfile</code>的大致流程：</p><ul><li>1.<code>docker</code>从基础镜像运行一个容器</li><li>2.执行一条指令并对容器作出修改</li><li>3.执行类似<code>docker commit</code>的操作提交一个新的镜像层</li><li>4.<code>docker</code>再基于刚提交的镜像运行一个新容器</li><li>5.执行<code>dockerfile</code>中的下一条指令直到所有指令都执行完成</li></ul><h3 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结"><span>小总结</span></a></h3><p>从应用软件的角度来看，<code>Dockerfile</code>、<code>Docker</code>镜像与<code>Docker</code>容器分别代表软件的三个不同阶段：</p><ul><li><code>Dockerfile</code>是软件的原材料</li><li><code>Docker</code>镜像是软件的交付品</li><li><code>Docker</code>容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li></ul><p><code>Dockerfile</code>面向开发，<code>Docker</code>镜像成为交付标准，<code>Docker</code>容器则涉及部署与运维，三者缺一不可，合力充当<code>Docker</code>体系的基石。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>1.<code>Dockerfile</code>定义了进程需要的一切东西。<code>Dockerfile</code>涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计<code>namespace</code>的权限控制)等等;</li><li>2.<code>Docker</code>镜像，在用<code>Dockerfile</code>定义一个文件之后，<code>docker build</code>时会产生一个<code>Docker</code>镜像，当运行 <code>Docker</code>镜像时会真正开始提供服务;</li><li>3.<code>Docker</code>容器，容器是直接提供服务的。</li></ul><h2 id="常用保留字指令" tabindex="-1"><a class="header-anchor" href="#常用保留字指令"><span>常用保留字指令</span></a></h2><p>参考tomcat8的dockerfile入门</p><p><a href="https://github.com/docker-library/tomcat" target="_blank" rel="noopener noreferrer">https://github.com/docker-library/tomcat</a></p><p>FROM</p><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><p>MAINTAINER</p><p>镜像维护者的姓名和邮箱地址</p><p>RUN</p><p>容器构建时需要运行的命令</p><p>两种格式</p><p>shell格式</p><p>RUN yum -y install vim</p><p>exec格式</p><p>RUN是在 docker build时运行</p><p>EXPOSE</p><p>当前容器对外暴露出的端口</p><p>WORKDIR</p><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><p>USER</p><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><p>ENV</p><p>用来在构建镜像过程中设置环境变量</p><p>ENV MY_PATH /usr/mytest<br> 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；<br> 也可以在其它指令中直接使用这些环境变量，<br>  <br> 比如：WORKDIR $MY_PATH</p><p>ADD</p><p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p><p>COPY</p><p>类似ADD，拷贝文件和目录到镜像中。<br> 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><p>COPY src dest</p><p>COPY [&quot;src&quot;, &quot;dest&quot;]</p><p>&lt;src源路径&gt;：源文件或者源目录</p><p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><p>VOLUME</p><p>容器数据卷，用于数据保存和持久化工作</p><p>CMD</p><p>指定容器启动后的要干的事情</p><p>注意</p><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p>参考官网Tomcat的dockerfile演示讲解</p><p>官网最后一行命令</p><p>它和前面RUN命令的区别</p><p>CMD是在docker run 时运行。</p><p>RUN是在 docker build时运行。</p><p>ENTRYPOINT</p><p>也是用来指定一个容器启动时要运行的命令</p><p>类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，<br> 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><p>命令格式和案例说明</p><p>命令格式：<br> ENTRYPOINT可以和CMD一起用，一般是 变参 才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。<br> 当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成<br>  <br> 案例如下： 假设已通过 Dockerfile 构建了  nginx:test 镜像 ：</p><p>是否传参<br> 按照dockerfile编写执行<br> 传参运行<br> Docker命令<br> docker run  nginx:test<br> docker run  nginx:test -c /etc/nginx/ new.conf<br> 衍生出的实际命令<br> nginx -c /etc/nginx/nginx.conf<br> nginx -c /etc/nginx/ new.conf</p><p>优点</p><p>在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p>注意</p><p>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><h3 id="小总结-1" tabindex="-1"><a class="header-anchor" href="#小总结-1"><span>小总结</span></a></h3><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',73),n=[t];function a(k,s){return c(),o("div",null,n)}const u=e(p,[["render",a],["__file","dockerFileAnalyze.html.vue"]]),g=JSON.parse('{"path":"/docker/dockerFileAnalyze.html","title":"","lang":"zh-CN","frontmatter":{"article":false,"description":"dockerFile解析 是什么 Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 概述概述 构建三步骤： 1.编写Dockerfile文件 2.docker build命令构建镜像 3.docker run依镜像运行容器实例 Dockerfile内容基础知识 1：每条保留字指令都必须为大写字母且...","head":[["meta",{"property":"og:url","content":"https://hanekawa.top/docker/dockerFileAnalyze.html"}],["meta",{"property":"og:site_name","content":"Kamishima-kaede"}],["meta",{"property":"og:description","content":"dockerFile解析 是什么 Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 概述概述 构建三步骤： 1.编写Dockerfile文件 2.docker build命令构建镜像 3.docker run依镜像运行容器实例 Dockerfile内容基础知识 1：每条保留字指令都必须为大写字母且..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-16T15:17:15.000Z"}],["meta",{"property":"article:author","content":"kamishima-kaede"}],["meta",{"property":"article:modified_time","content":"2023-04-16T15:17:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"\\",\\"description\\":\\"dockerFile解析 是什么 Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 概述概述 构建三步骤： 1.编写Dockerfile文件 2.docker build命令构建镜像 3.docker run依镜像运行容器实例 Dockerfile内容基础知识 1：每条保留字指令都必须为大写字母且...\\"}"]]},"headers":[{"level":2,"title":"dockerFile解析","slug":"dockerfile解析","link":"#dockerfile解析","children":[{"level":3,"title":"是什么","slug":"是什么","link":"#是什么","children":[]}]},{"level":2,"title":"Dockerfile内容基础知识","slug":"dockerfile内容基础知识","link":"#dockerfile内容基础知识","children":[{"level":3,"title":"小总结","slug":"小总结","link":"#小总结","children":[]}]},{"level":2,"title":"常用保留字指令","slug":"常用保留字指令","link":"#常用保留字指令","children":[{"level":3,"title":"小总结","slug":"小总结-1","link":"#小总结-1","children":[]}]}],"git":{"createdTime":1681658235000,"updatedTime":1681658235000,"contributors":[{"name":"shiki ryougi","email":"shikiryougi@shikideMacBook.local","commits":1}]},"readingTime":{"minutes":4.35,"words":1306},"filePathRelative":"docker/dockerFileAnalyze.md","localizedDate":"2023年4月16日","excerpt":"<h2><code>dockerFile</code>解析</h2>\\n<h3>是什么</h3>\\n<p><a href=\\"https://docs.docker.com/engine/reference/builder/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Dockerfile</a>是用来构建<code>Docker</code>镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\\n<figure><figcaption>概述</figcaption></figure>\\n<p>构建三步骤：</p>\\n<ul>\\n<li>1.编写<code>Dockerfile</code>文件</li>\\n<li>2.<code>docker build</code>命令构建镜像</li>\\n<li>3.<code>docker run</code>依镜像运行容器实例</li>\\n</ul>","autoDesc":true}');export{u as comp,g as data};
